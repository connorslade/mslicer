use std::{
    fs::File,
    io::{Read, Seek},
    time::Instant,
};

use anyhow::Result;
use format::goo::HeaderInfo;
use image::{Rgb, RgbImage};
use nalgebra::{Vector2, Vector3};
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};

mod format;

type Pos = Vector3<f32>;

struct Mesh {
    vertices: Vec<Pos>,
    faces: Vec<[usize; 3]>,

    position: Pos,
    scale: Pos,
}

struct SliceConfig {
    platform_resolution: Vector2<u32>,
    platform_size: Vector3<f32>,
    slice_height: f32,
}

/*
[dependencies]

*/

const DATA: &[u8] = &[
    0x3E, 0x1B, 0x3A, 0xC5, 0x82, 0x8D, 0x8C, 0xA4, 0xAE, 0x2D, 0x02, 0xCE, 0x8B, 0x41, 0x32, 0x41,
    0x59, 0x41, 0x6E, 0x8D, 0x8D, 0x8E, 0x8D, 0x8D, 0x8D, 0x8E, 0x8D, 0x8E, 0x8E, 0x8A, 0xC4, 0xA5,
    0xAD, 0xAD, 0xAE, 0xAE, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAE, 0x41, 0x4B, 0x41, 0x22, 0x41,
    0x02, 0x28, 0x02, 0xCD, 0x41, 0x18, 0x41, 0x3F, 0x41, 0x68, 0x41, 0x91, 0x41, 0xB9, 0x41, 0xE2,
    0x41, 0xFE, 0xD0, 0x02, 0xA8, 0x41, 0xD1, 0x41, 0xA8, 0x41, 0x7F, 0x41, 0x57, 0x41, 0x2F, 0x41,
    0x08, 0x2C, 0x02, 0xCC, 0x41, 0x11, 0x41, 0x4C, 0x41, 0x76, 0x41, 0x9E, 0x41, 0xC7, 0x41, 0xEE,
    0xDD, 0x02, 0xA2, 0x41, 0xDE, 0x41, 0xB6, 0x41, 0x8D, 0x41, 0x65, 0x41, 0x35, 0x41, 0x03, 0x22,
    0x02, 0xCC, 0x85, 0x41, 0x3E, 0x41, 0x84, 0x41, 0xC9, 0x41, 0xFD, 0xD8, 0x03, 0x41, 0xEF, 0x41,
    0xAD, 0x41, 0x67, 0x41, 0x22, 0x2C, 0x02, 0xCB, 0x41, 0x29, 0x41, 0x6E, 0x41, 0xB3, 0x41, 0xF3,
    0xD0, 0x04, 0x41, 0xDD, 0x41, 0x98, 0x41, 0x53, 0x41, 0x10, 0x24, 0x02, 0xCB, 0x41, 0x15, 0x41,
    0x59, 0x41, 0x9E, 0x41, 0xE3, 0xD7, 0x04, 0xA3, 0x41, 0xC8, 0x41, 0x82, 0x41, 0x3D, 0x41, 0x05,
    0x2D, 0x02, 0xCA, 0x8E, 0x41, 0x68, 0x41, 0xC9, 0x41, 0xFE, 0xDE, 0x04, 0xAD, 0x41, 0xA3, 0x41,
    0x3F, 0x29, 0x02, 0xCA, 0x41, 0x3B, 0x41, 0x9F, 0x41, 0xF5, 0xD4, 0x05, 0x41, 0xDA, 0x41, 0x77,
    0x41, 0x17, 0x23, 0x02, 0xCA, 0x41, 0x14, 0x41, 0x72, 0x41, 0xD6, 0xD9, 0x05, 0xA4, 0x41, 0xAE,
    0x41, 0x4A, 0x41, 0x02, 0x2D, 0x02, 0xC9, 0x81, 0x41, 0x46, 0x41, 0xAA, 0x41, 0xF9, 0xDE, 0x05,
    0x41, 0xE3, 0x41, 0x81, 0x41, 0x1F, 0x29, 0x02, 0xC9, 0x41, 0x18, 0x41, 0x7D, 0x41, 0xDF, 0xD3,
    0x06, 0xA2, 0x41, 0xB9, 0x41, 0x54, 0x41, 0x03, 0x24, 0x02, 0xC9, 0x41, 0x11, 0x41, 0x89, 0x41,
    0xF6, 0xD8, 0x06, 0x41, 0xD5, 0x41, 0x50, 0x21, 0x02, 0xC9, 0x8A, 0x41, 0x79, 0x41, 0xEF, 0xDC,
    0x06, 0x41, 0xC7, 0x41, 0x3F, 0x2D, 0x02, 0xC8, 0x84, 0x41, 0x68, 0x41, 0xE6, 0xD0, 0x07, 0x41,
    0xB6, 0x41, 0x30, 0x29, 0x02, 0xC8, 0x81, 0x41, 0x59, 0x41, 0xDB, 0xD3, 0x07, 0xA1, 0x41, 0xA7,
    0x41, 0x24, 0x26, 0x02, 0xC8, 0x41, 0x49, 0x41, 0xCF, 0xD7, 0x07, 0xA4, 0x41, 0x99, 0x41, 0x1A,
    0x22, 0x02, 0xC8, 0x41, 0x30, 0x41, 0xC1, 0xDB, 0x07, 0xA9, 0x41, 0x88, 0x41, 0x09, 0x2E, 0x02,
    0xC7, 0x82, 0x41, 0x79, 0x41, 0xFA, 0xDE, 0x07, 0x41, 0xD8, 0x41, 0x35, 0x2C, 0x02, 0xC7, 0x41,
    0x21, 0x41, 0xC4, 0xD1, 0x08, 0xA4, 0x41, 0x7F, 0x41, 0x04, 0x29, 0x02, 0xC7, 0x41, 0x63, 0x41,
    0xF2, 0xD4, 0x08, 0x41, 0xC9, 0x41, 0x25, 0x26, 0x02, 0xC7, 0x41, 0x15, 0x41, 0xB0, 0xD7, 0x08,
    0xAA, 0x41, 0x69, 0x24, 0x02, 0xC7, 0x41, 0x4D, 0x41, 0xE9, 0xDA, 0x08, 0x41, 0xB5, 0x41, 0x18,
    0x20, 0x02, 0xC7, 0x8C, 0x41, 0x9B, 0xDD, 0x08, 0x41, 0xEB, 0x41, 0x52, 0x2E, 0x02, 0xC6, 0x41,
    0x2B, 0x41, 0xDC, 0xD0, 0x09, 0x41, 0x9B, 0x41, 0x04, 0x2B, 0x02, 0xC6, 0x41, 0x3C, 0x41, 0xEE,
    0xD2, 0x09, 0x41, 0xB7, 0x41, 0x0B, 0x29, 0x02, 0xC6, 0x41, 0x4F, 0x41, 0xF7, 0xD4, 0x09, 0x41,
    0xCA, 0x41, 0x15, 0x27, 0x02, 0xC6, 0x41, 0x65, 0x41, 0xFC, 0xD6, 0x09, 0x41, 0xDA, 0x41, 0x21,
    0x25, 0x02, 0xC6, 0x41, 0x7C, 0xD9, 0x09, 0x41, 0xE7, 0x41, 0x30, 0x22, 0x02, 0xC6, 0x82, 0x41,
    0x96, 0xDB, 0x09, 0xAE, 0x41, 0x41, 0x20, 0x02, 0xC6, 0x87, 0x41, 0xAD, 0xDD, 0x09, 0xA7, 0x41,
    0x55, 0x2E, 0x02, 0xC5, 0x41, 0x10, 0x41, 0xC1, 0xDF, 0x09, 0xA2, 0x41, 0x6B, 0x2C, 0x02, 0xC5,
    0x8A, 0x41, 0xCB, 0xD2, 0x0A, 0x41, 0x6E, 0x2A, 0x02, 0xC5, 0x81, 0x41, 0xAE, 0xD3, 0x0A, 0xA3,
    0x41, 0x4A, 0x29, 0x02, 0xC5, 0x41, 0x89, 0xD5, 0x0A, 0xAD, 0x41, 0x2D, 0x27, 0x02, 0xC5, 0x41,
    0x62, 0xD7, 0x0A, 0x41, 0xE1, 0x41, 0x18, 0x25, 0x02, 0xC5, 0x41, 0x40, 0x41, 0xFA, 0xD8, 0x0A,
    0x41, 0xC9, 0x41, 0x09, 0x23, 0x02, 0xC5, 0x41, 0x26, 0x41, 0xED, 0xDA, 0x0A, 0x41, 0xAA, 0x41,
    0x01, 0x21, 0x02, 0xC5, 0x41, 0x12, 0x41, 0xDA, 0xDC, 0x0A, 0x41, 0x84, 0x20, 0x02, 0xC5, 0x86,
    0x41, 0xC0, 0xDE, 0x0A, 0x41, 0x5E, 0x2F, 0x02, 0xC4, 0x41, 0x9D, 0xDF, 0x0A, 0xA6, 0x41, 0x3C,
    0x2D, 0x02, 0xC4, 0x41, 0x4F, 0xD1, 0x0B, 0x41, 0xDD, 0x41, 0x09, 0x2B, 0x02, 0xC4, 0x8C, 0x41,
    0xE2, 0xD2, 0x0B, 0x41, 0x87, 0x2B, 0x02, 0xC4, 0x41, 0x8F, 0xD3, 0x0B, 0xA5, 0x41, 0x2C, 0x29,
    0x02, 0xC4, 0x41, 0x31, 0x41, 0xFC, 0xD4, 0x0B, 0x41, 0xC6, 0x41, 0x01, 0x27, 0x02, 0xC4, 0x82,
    0x41, 0xCB, 0xD6, 0x0B, 0x41, 0x68, 0x27, 0x02, 0xC4, 0x41, 0x6E, 0xD7, 0x0B, 0x41, 0xEF, 0x41,
    0x18, 0x25, 0x02, 0xC4, 0x41, 0x1C, 0x41, 0xF2, 0xD8, 0x0B, 0x41, 0xA9, 0x25, 0x02, 0xC4, 0x41,
    0xAF, 0xDA, 0x0B, 0x41, 0x49, 0x23, 0x02, 0xC4, 0x41, 0x4F, 0xDB, 0x0B, 0x41, 0xDF, 0x41, 0x0A,
    0x21, 0x02, 0xC4, 0x82, 0x41, 0xDB, 0xDC, 0x0B, 0x41, 0x78, 0x21, 0x02, 0xC4, 0x41, 0x4D, 0xDD,
    0x0B, 0x41, 0xE2, 0x41, 0x04, 0x20, 0x02, 0xC4, 0x41, 0xBC, 0xDE, 0x0B, 0x41, 0x55, 0x2F, 0x02,
    0xC3, 0x41, 0x2C, 0xDF, 0x0B, 0x41, 0xC4, 0x2F, 0x02, 0xC3, 0x41, 0x9A, 0xD0, 0x0C, 0x41, 0x32,
    0x2D, 0x02, 0xC3, 0x41, 0x12, 0x41, 0xF6, 0xD0, 0x0C, 0x41, 0xA0, 0x2D, 0x02, 0xC3, 0x41, 0x77,
    0xD1, 0x0C, 0xA7, 0x41, 0x15, 0x2B, 0x02, 0xC3, 0x83, 0x41, 0xE1, 0xD2, 0x0C, 0x41, 0x7C, 0x2B,
    0x02, 0xC3, 0x41, 0x53, 0xD3, 0x0C, 0x41, 0xE5, 0x41, 0x04, 0x2A, 0x02, 0xC3, 0x41, 0xC1, 0xD4,
    0x0C, 0x41, 0x58, 0x29, 0x02, 0xC3, 0x41, 0x21, 0xD5, 0x0C, 0x41, 0xB8, 0x29, 0x02, 0xC3, 0x41,
    0x63, 0xD5, 0x0C, 0xAB, 0x41, 0x05, 0x28, 0x02, 0xC3, 0x41, 0xA4, 0xD6, 0x0C, 0x41, 0x3A, 0x28,
    0x02, 0xC3, 0x41, 0xE5, 0xD6, 0x0C, 0x41, 0x7B, 0x27, 0x02, 0xC3, 0x41, 0x26, 0xD7, 0x0C, 0x41,
    0xBB, 0x27, 0x02, 0xC3, 0x41, 0x67, 0xD7, 0x0C, 0xAA, 0x41, 0x06, 0x26, 0x02, 0xC3, 0x41, 0xA7,
    0xD8, 0x0C, 0x41, 0x3C, 0x26, 0x02, 0xC3, 0x41, 0xE7, 0xD8, 0x0C, 0x41, 0x7D, 0x25, 0x02, 0xC3,
    0x41, 0x28, 0xD9, 0x0C, 0x41, 0xBE, 0x25, 0x02, 0xC3, 0x41, 0x69, 0xD9, 0x0C, 0xA8, 0x41, 0x07,
    0x24, 0x02, 0xC3, 0x41, 0xA8, 0xDA, 0x0C, 0x41, 0x40, 0x24, 0x02, 0xC3, 0x41, 0xCE, 0xDA, 0x0C,
    0x41, 0x65, 0x24, 0x02, 0xC3, 0x41, 0xE3, 0xDA, 0x0C, 0x41, 0x7A, 0x24, 0x02, 0xC3, 0x41, 0xF8,
    0xDA, 0x0C, 0x41, 0x90, 0x23, 0x02, 0xC3, 0x8D, 0xDB, 0x0C, 0x41, 0xA5, 0x23, 0x02, 0xC3, 0x41,
    0x22, 0xDB, 0x0C, 0x41, 0xBA, 0x23, 0x02, 0xC3, 0x41, 0x37, 0xDB, 0x0C, 0x41, 0xCF, 0x23, 0x02,
    0xC3, 0x41, 0x4C, 0xDB, 0x0C, 0x41, 0xE4, 0x23, 0x02, 0xC3, 0x41, 0x61, 0xDB, 0x0C, 0xA6, 0x23,
    0x02, 0xC3, 0x41, 0x77, 0xDC, 0x0C, 0x41, 0x0E, 0x22, 0x02, 0xC3, 0x41, 0x8C, 0xDC, 0x0C, 0x41,
    0x23, 0x22, 0x02, 0xC3, 0x41, 0xA1, 0xDC, 0x0C, 0x41, 0x39, 0x22, 0x02, 0xC3, 0x41, 0xA1, 0xDC,
    0x0C, 0x41, 0x39, 0x22, 0x02, 0xC3, 0x41, 0x8C, 0xDC, 0x0C, 0x41, 0x23, 0x22, 0x02, 0xC3, 0x41,
    0x77, 0xDC, 0x0C, 0x41, 0x0E, 0x22, 0x02, 0xC3, 0x41, 0x62, 0xDB, 0x0C, 0xA7, 0x23, 0x02, 0xC3,
    0x41, 0x4D, 0xDB, 0x0C, 0x41, 0xE3, 0x23, 0x02, 0xC3, 0x41, 0x38, 0xDB, 0x0C, 0x41, 0xCE, 0x23,
    0x02, 0xC3, 0x41, 0x23, 0xDB, 0x0C, 0x41, 0xB9, 0x23, 0x02, 0xC3, 0x8E, 0xDB, 0x0C, 0x41, 0xA4,
    0x24, 0x02, 0xC3, 0x41, 0xF8, 0xDA, 0x0C, 0x41, 0x8F, 0x24, 0x02, 0xC3, 0x41, 0xE3, 0xDA, 0x0C,
    0x41, 0x7A, 0x24, 0x02, 0xC3, 0x41, 0xCE, 0xDA, 0x0C, 0x41, 0x65, 0x24, 0x02, 0xC3, 0x41, 0xA8,
    0xDA, 0x0C, 0x41, 0x40, 0x24, 0x02, 0xC3, 0x41, 0x68, 0xD9, 0x0C, 0xA7, 0x41, 0x08, 0x24, 0x02,
    0xC3, 0x41, 0x27, 0xD9, 0x0C, 0x41, 0xBF, 0x26, 0x02, 0xC3, 0x41, 0xE6, 0xD8, 0x0C, 0x41, 0x7F,
    0x26, 0x02, 0xC3, 0x41, 0xA5, 0xD8, 0x0C, 0x41, 0x3E, 0x26, 0x02, 0xC3, 0x41, 0x64, 0xD7, 0x0C,
    0xA9, 0x41, 0x07, 0x26, 0x02, 0xC3, 0x41, 0x24, 0xD7, 0x0C, 0x41, 0xBD, 0x28, 0x02, 0xC3, 0x41,
    0xE3, 0xD6, 0x0C, 0x41, 0x7C, 0x28, 0x02, 0xC3, 0x41, 0xA3, 0xD6, 0x0C, 0x41, 0x3B, 0x28, 0x02,
    0xC3, 0x41, 0x63, 0xD5, 0x0C, 0xAB, 0x41, 0x05, 0x28, 0x02, 0xC3, 0x41, 0x21, 0xD5, 0x0C, 0x41,
    0xB8, 0x2A, 0x02, 0xC3, 0x41, 0xC1, 0xD4, 0x0C, 0x41, 0x58, 0x2A, 0x02, 0xC3, 0x41, 0x53, 0xD3,
    0x0C, 0x41, 0xE4, 0x41, 0x04, 0x2A, 0x02, 0xC3, 0x83, 0x41, 0xE1, 0xD2, 0x0C, 0x41, 0x7C, 0x2C,
    0x02, 0xC3, 0x41, 0x77, 0xD1, 0x0C, 0xA7, 0x41, 0x15, 0x2C, 0x02, 0xC3, 0x41, 0x12, 0x41, 0xF6,
    0xD0, 0x0C, 0x41, 0xA0, 0x2E, 0x02, 0xC3, 0x41, 0x9A, 0xD0, 0x0C, 0x41, 0x32, 0x2E, 0x02, 0xC3,
    0x41, 0x2D, 0xDF, 0x0B, 0x41, 0xC4, 0x20, 0x02, 0xC4, 0x41, 0xBE, 0xDE, 0x0B, 0x41, 0x56, 0x20,
    0x02, 0xC4, 0x41, 0x50, 0xDD, 0x0B, 0x41, 0xE3, 0x41, 0x04, 0x20, 0x02, 0xC4, 0x82, 0x41, 0xDE,
    0xDC, 0x0B, 0x41, 0x78, 0x22, 0x02, 0xC4, 0x41, 0x53, 0xDB, 0x0B, 0x41, 0xDF, 0x41, 0x0A, 0x23,
    0x02, 0xC4, 0x41, 0xB2, 0xDA, 0x0B, 0x41, 0x49, 0x24, 0x02, 0xC4, 0x41, 0x1D, 0x41, 0xF3, 0xD8,
    0x0B, 0x41, 0xA9, 0x26, 0x02, 0xC4, 0x41, 0x71, 0xD7, 0x0B, 0xAF, 0x41, 0x18, 0x26, 0x02, 0xC4,
    0x83, 0x41, 0xCD, 0xD6, 0x0B, 0x41, 0x69, 0x28, 0x02, 0xC4, 0x41, 0x33, 0x41, 0xFC, 0xD4, 0x0B,
    0x41, 0xC6, 0x41, 0x01, 0x29, 0x02, 0xC4, 0x41, 0x90, 0xD3, 0x0B, 0xA4, 0x41, 0x2D, 0x2A, 0x02,
    0xC4, 0x8C, 0x41, 0xE3, 0xD2, 0x0B, 0x41, 0x87, 0x2C, 0x02, 0xC4, 0x41, 0x50, 0xD1, 0x0B, 0x41,
    0xDD, 0x41, 0x09, 0x2D, 0x02, 0xC4, 0x41, 0x9D, 0xDF, 0x0A, 0xA6, 0x41, 0x3C, 0x2E, 0x02, 0xC4,
    0x85, 0x41, 0xC0, 0xDE, 0x0A, 0x41, 0x5D, 0x20, 0x02, 0xC5, 0x41, 0x12, 0x41, 0xDA, 0xDC, 0x0A,
    0x41, 0x84, 0x22, 0x02, 0xC5, 0x41, 0x26, 0x41, 0xEE, 0xDA, 0x0A, 0x41, 0xA9, 0x41, 0x01, 0x23,
    0x02, 0xC5, 0x41, 0x40, 0x41, 0xFA, 0xD8, 0x0A, 0x41, 0xC8, 0x41, 0x08, 0x25, 0x02, 0xC5, 0x41,
    0x63, 0xD7, 0x0A, 0x41, 0xE0, 0x41, 0x17, 0x27, 0x02, 0xC5, 0x41, 0x89, 0xD5, 0x0A, 0xAD, 0x41,
    0x2D, 0x28, 0x02, 0xC5, 0x81, 0x41, 0xAE, 0xD3, 0x0A, 0xA3, 0x41, 0x4A, 0x2A, 0x02, 0xC5, 0x8A,
    0x41, 0xCB, 0xD2, 0x0A, 0x41, 0x6D, 0x2C, 0x02, 0xC5, 0x41, 0x10, 0x41, 0xC1, 0xDF, 0x09, 0xA2,
    0x41, 0x6A, 0x2E, 0x02, 0xC5, 0x88, 0x41, 0xAE, 0xDD, 0x09, 0xA7, 0x41, 0x53, 0x20, 0x02, 0xC6,
    0x82, 0x41, 0x98, 0xDB, 0x09, 0xAF, 0x41, 0x3F, 0x23, 0x02, 0xC6, 0x41, 0x7F, 0xD9, 0x09, 0x41,
    0xE5, 0x41, 0x2E, 0x25, 0x02, 0xC6, 0x41, 0x66, 0x41, 0xFC, 0xD6, 0x09, 0x41, 0xD8, 0x41, 0x1F,
    0x27, 0x02, 0xC6, 0x41, 0x50, 0x41, 0xF7, 0xD4, 0x09, 0x41, 0xC8, 0x41, 0x14, 0x29, 0x02, 0xC6,
    0x41, 0x3C, 0x41, 0xEE, 0xD2, 0x09, 0x41, 0xB6, 0x41, 0x0A, 0x2B, 0x02, 0xC6, 0x41, 0x2B, 0x41,
    0xDC, 0xD0, 0x09, 0x41, 0x9A, 0x41, 0x04, 0x2D, 0x02, 0xC6, 0x8C, 0x41, 0x9B, 0xDD, 0x08, 0x41,
    0xEB, 0x41, 0x51, 0x21, 0x02, 0xC7, 0x41, 0x4D, 0x41, 0xE9, 0xDA, 0x08, 0x41, 0xB4, 0x41, 0x17,
    0x23, 0x02, 0xC7, 0x41, 0x15, 0x41, 0xB0, 0xD7, 0x08, 0xAB, 0x41, 0x67, 0x27, 0x02, 0xC7, 0x41,
    0x63, 0x41, 0xF3, 0xD4, 0x08, 0x41, 0xC7, 0x41, 0x24, 0x29, 0x02, 0xC7, 0x41, 0x22, 0x41, 0xC4,
    0xD1, 0x08, 0xA4, 0x41, 0x7D, 0x41, 0x03, 0x2B, 0x02, 0xC7, 0x82, 0x41, 0x79, 0x41, 0xFA, 0xDE,
    0x07, 0x41, 0xD8, 0x41, 0x34, 0x2F, 0x02, 0xC7, 0x41, 0x30, 0x41, 0xC1, 0xDB, 0x07, 0xA9, 0x41,
    0x88, 0x41, 0x09, 0x22, 0x02, 0xC8, 0x41, 0x49, 0x41, 0xCF, 0xD7, 0x07, 0xA4, 0x41, 0x99, 0x41,
    0x1A, 0x25, 0x02, 0xC8, 0x81, 0x41, 0x59, 0x41, 0xDC, 0xD3, 0x07, 0xA1, 0x41, 0xA8, 0x41, 0x25,
    0x29, 0x02, 0xC8, 0x85, 0x41, 0x69, 0x41, 0xE6, 0xD0, 0x07, 0x41, 0xB8, 0x41, 0x31, 0x2D, 0x02,
    0xC8, 0x8A, 0x41, 0x79, 0x41, 0xEF, 0xDC, 0x06, 0x41, 0xC7, 0x41, 0x40, 0x21, 0x02, 0xC9, 0x41,
    0x11, 0x41, 0x88, 0x41, 0xF6, 0xD8, 0x06, 0x41, 0xD5, 0x41, 0x50, 0x25, 0x02, 0xC9, 0x41, 0x18,
    0x41, 0x7C, 0x41, 0xDF, 0xD3, 0x06, 0xA2, 0x41, 0xB8, 0x41, 0x53, 0x41, 0x02, 0x28, 0x02, 0xC9,
    0x81, 0x41, 0x45, 0x41, 0xAA, 0x41, 0xF9, 0xDE, 0x05, 0x41, 0xE1, 0x41, 0x80, 0x41, 0x1E, 0x2E,
    0x02, 0xC9, 0x41, 0x14, 0x41, 0x72, 0x41, 0xD6, 0xD9, 0x05, 0xA5, 0x41, 0xAD, 0x41, 0x48, 0x41,
    0x02, 0x23, 0x02, 0xCA, 0x41, 0x3B, 0x41, 0x9F, 0x41, 0xF5, 0xD4, 0x05, 0x41, 0xD9, 0x41, 0x75,
    0x41, 0x16, 0x28, 0x02, 0xCA, 0x8E, 0x41, 0x67, 0x41, 0xC9, 0x41, 0xFE, 0xDE, 0x04, 0xAD, 0x41,
    0xA3, 0x41, 0x3E, 0x2E, 0x02, 0xCA, 0x41, 0x15, 0x41, 0x59, 0x41, 0x9E, 0x41, 0xE3, 0xD7, 0x04,
    0xA3, 0x41, 0xC6, 0x41, 0x81, 0x41, 0x3C, 0x41, 0x04, 0x24, 0x02, 0xCB, 0x41, 0x29, 0x41, 0x6E,
    0x41, 0xB3, 0x41, 0xF3, 0xD0, 0x04, 0x41, 0xDB, 0x41, 0x96, 0x41, 0x51, 0x41, 0x0F, 0x2B, 0x02,
    0xCB, 0x85, 0x41, 0x3E, 0x41, 0x83, 0x41, 0xC8, 0x41, 0xFC, 0xD8, 0x03, 0x41, 0xEE, 0x41, 0xAB,
    0x41, 0x66, 0x41, 0x21, 0x23, 0x02, 0xCC, 0x41, 0x10, 0x41, 0x4B, 0x41, 0x75, 0x41, 0x9D, 0x41,
    0xC5, 0x41, 0xEE, 0xDD, 0x02, 0xA2, 0x41, 0xDE, 0x41, 0xB5, 0x41, 0x8D, 0x41, 0x64, 0x41, 0x35,
    0x41, 0x02, 0x2C, 0x02, 0xCC, 0x41, 0x16, 0x41, 0x3F, 0x41, 0x67, 0x41, 0x8F, 0x41, 0xB8, 0x41,
    0xE0, 0x41, 0xFE, 0xD0, 0x02, 0xA8, 0x41, 0xD1, 0x41, 0xA8, 0x41, 0x80, 0x41, 0x58, 0x41, 0x2F,
    0x41, 0x09, 0x28, 0x02, 0xCD, 0x8A, 0x41, 0x31, 0x41, 0x59, 0x41, 0x6D, 0x8D, 0x8D, 0x8D, 0x8D,
    0x8D, 0x8D, 0x8E, 0x8E, 0x8D, 0x8E, 0x8C, 0xC4, 0xA5, 0xAD, 0xAD, 0xAE, 0xAE, 0xAD, 0xAD, 0xAE,
    0xAD, 0xAD, 0xAD, 0xAD, 0x41, 0x4A, 0x41, 0x22, 0x41, 0x02, 0x2C, 0x02, 0xCE, 0x81, 0x8D, 0x8D,
    0xA5, 0xAE, 0x3D, 0x1B, 0x3A, 0xC9,
];

fn main() -> Result<()> {
    let mut checksum = 0u8;
    for &byte in DATA {
        checksum = checksum.wrapping_add(byte);
    }

    if !checksum != 0x61 {
        panic!("Checksum failed: 0x{checksum:X}");
    }

    let mut image = RgbImage::new(11520, 5120);
    let mut pixel = 0;

    let mut i = 0;
    let mut color = 0u8;
    let mut length = 0_u64;

    while i < DATA.len() {
        let head = DATA[i];

        // 0b00 -> All 0x00 pixels
        // 0b01 -> Gray between 0x01 to 0xFE (byte 1)
        // 0b10 -> Diff value from the previous pixel
        // 0b11 -> All 0xFF pixels
        let chunk_type = head >> 6;
        let chunk_length_size = head >> 4 & 0x03;

        match chunk_type {
            0b00 => color = 0,
            0b01 => {
                i += 1;
                color = DATA[i]
            }
            0b10 => {
                let diff_type = head >> 4 & 0x03;
                let diff_value = head & 0x0F;

                if diff_type & 0b01 == 0 {
                    length = 1;
                } else {
                    i += 1;
                    length = DATA[i] as u64;
                }

                if diff_type & 0b10 == 0 {
                    color += diff_value;
                } else {
                    color -= diff_value;
                }
            }
            0b11 => color = 0xFF,
            _ => unreachable!(),
        };

        if chunk_type != 0b10 {
            let base = (head & 0x0F) as u64;
            match chunk_length_size {
                0b00 => length = base,
                0b01 => {
                    length = base + ((DATA[i + 1] as u64) << 4);
                    i += 1;
                }
                0b10 => {
                    length = base + ((DATA[i + 1] as u64) << 12) + ((DATA[i + 2] as u64) << 4);
                    i += 2;
                }
                0b11 => {
                    length = base
                        + ((DATA[i + 1] as u64) << 20)
                        + ((DATA[i + 2] as u64) << 12)
                        + ((DATA[i + 3] as u64) << 4);
                    i += 3;
                }
                _ => unreachable!(),
            };
        }

        i += 1;

        for _ in 0..length {
            let x = pixel % 11520;
            let y = pixel / 11520;

            image.put_pixel(x as u32, y as u32, Rgb([color, color, color]));
            pixel += 1;
        }
    }

    image.save("output.png")?;
    return Ok(());

    const FILE_PATH: &str = "teapot.stl";

    let slice_config = SliceConfig {
        // platform_resolution: Vector2::new(1920, 1080),
        platform_resolution: Vector2::new(11520, 5121),
        platform_size: Vector3::new(218.88, 122.904, 260.0),
        slice_height: 0.05,
    };

    let mut file = File::open(FILE_PATH)?;
    let mut mesh = load_mesh(&mut file, "stl")?;
    let (min, max) = mesh.minmax_point();

    let real_scale = 15.0;
    mesh.scale = Pos::new(real_scale, real_scale, real_scale);

    let center = slice_config.platform_resolution / 2;
    let mesh_center = (min + max) / 2.0;
    mesh.position = Vector3::new(
        center.x as f32 - mesh_center.x,
        center.y as f32 - mesh_center.y,
        mesh.position.z,
    );

    println!(
        "Loaded mesh. {{ vert: {}, face: {} }}",
        mesh.vertices.len(),
        mesh.faces.len()
    );

    let now = Instant::now();

    let mut height = 0.0;
    let mut i = 0;

    let plane_normal = Pos::new(0.0, 0.0, 1.0);
    let mut image = RgbImage::new(
        slice_config.platform_resolution.x,
        slice_config.platform_resolution.y,
    );

    while height < max.z {
        let plane_point = Pos::new(0.0, 0.0, height);

        let intersections = mesh.intersect_plane(&plane_normal, &plane_point);
        println!("Height: {}, Intersections: {}", height, intersections.len());

        for intersection in intersections.chunks(2) {
            let a = intersection[0];
            let b = intersection[1];

            imageproc::drawing::draw_line_segment_mut(
                &mut image,
                (a.x, a.y),
                (b.x, b.y),
                image::Rgb([255, 255, 255]),
            );
        }

        let filename = format!("output/{i}.png");
        image.save(filename)?;
        image.fill(0);

        height += slice_config.slice_height;
        i += 1;
    }

    println!("Done. Elapsed: {:.1}s", now.elapsed().as_secs_f32());

    Ok(())
}

impl Mesh {
    pub fn minmax_point(&self) -> (Pos, Pos) {
        self.vertices.iter().fold(
            (
                Pos::new(f32::MAX, f32::MAX, f32::MAX),
                Pos::new(f32::MIN, f32::MIN, f32::MIN),
            ),
            |(min, max), v| {
                (
                    Pos::new(min.x.min(v.x), min.y.min(v.y), min.z.min(v.z)),
                    Pos::new(max.x.max(v.x), max.y.max(v.y), max.z.max(v.z)),
                )
            },
        )
    }

    pub fn intersect_plane(&self, normal: &Pos, point: &Pos) -> Vec<Pos> {
        self.faces
            .par_iter()
            .flat_map(|face| {
                let v0 = self.transform(&self.vertices[face[0]]);
                let v1 = self.transform(&self.vertices[face[1]]);
                let v2 = self.transform(&self.vertices[face[2]]);

                let d0 = v0 - point;
                let d1 = v1 - point;
                let d2 = v2 - point;

                let dot0 = normal.dot(&d0);
                let dot1 = normal.dot(&d1);
                let dot2 = normal.dot(&d2);

                let mut result = Vec::new();

                if dot0 * dot1 < 0.0 {
                    let t = dot0 / (dot0 - dot1);
                    let intersection = v0 + t * (v1 - v0);
                    result.push(intersection);
                }

                if dot1 * dot2 < 0.0 {
                    let t = dot1 / (dot1 - dot2);
                    let intersection = v1 + t * (v2 - v1);
                    result.push(intersection);
                }

                if dot2 * dot0 < 0.0 {
                    let t = dot2 / (dot2 - dot0);
                    let intersection = v2 + t * (v0 - v2);
                    result.push(intersection);
                }

                result
            })
            .collect()
    }

    fn transform(&self, pos: &Pos) -> Pos {
        Pos::new(
            pos.x * self.scale.x,
            pos.y * self.scale.y,
            pos.z * self.scale.z,
        ) + self.position
    }
}

fn load_mesh<T: Read + Seek>(reader: &mut T, format: &str) -> Result<Mesh> {
    match format {
        "stl" => {
            let modal = stl_io::read_stl(reader)?;
            Ok(Mesh {
                vertices: modal
                    .vertices
                    .iter()
                    .map(|v| Pos::new(v[0], v[1], v[2]))
                    .collect(),
                faces: modal
                    .faces
                    .iter()
                    .map(|f| [f.vertices[0], f.vertices[1], f.vertices[2]])
                    .collect(),

                position: Pos::new(0.0, 0.0, 0.0),
                scale: Pos::new(1.0, 1.0, 1.0),
            })
        }
        _ => Err(anyhow::anyhow!("Unsupported format: {}", format)),
    }
}
