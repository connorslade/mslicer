//! Post-processing refers to modifications and analyses run on the sliced models,
//! here it specifically provides a framework to run passes in `mslicer` and display
//! the results within the UI.

use std::{
    sync::{Arc, RwLock},
    thread::JoinHandle,
};

use common::{annotations::Annotations, config::SliceConfig};
use egui::Ui;
use parking_lot::Mutex;

use crate::app::slice_operation::SliceResult;

/// Represents the current progress of a running pass.
#[derive(Default)]
pub struct PassProgress {
    pub progress: f32,
    pub message: String,
}

/// The output of a pass can be a modified file or a read-only analysis report.
pub enum PassOutput {
    // Example: Modified(FormatSliceFile),
    Analysis(Box<dyn AnalysisReport>),
}

/// Generic interface for the analysis results.
pub trait AnalysisReport: Send + Sync {
    /// Renders the results of the analysis in the UI.
    fn ui(&self, ui: &mut Ui, slice_result: Arc<Mutex<Option<SliceResult>>>);

    /// Returns annotions generated by the most recent run of the pass.
    fn annotations(&self) -> &Annotations;
}

/// State machine for the passes.
#[derive(Clone, Copy, Debug, Default)]
pub enum PassState {
    #[default]
    Ready,
    Running {
        start_time: std::time::Instant,
    },
    Completed {
        run_time: std::time::Duration,
    },
}

/// Generic trait for post-processing passes.
pub trait Pass: Send + Sync {
    /// A unique identifier for the pass.
    fn name(&self) -> &'static str;

    /// A user-friendly description of what the pass does.
    fn description(&self) -> &'static str;

    /// Renders any configuration UI for this pass.
    fn ui(&mut self, ui: &mut Ui, cfg: &SliceConfig);

    /// Executes the pass in the background.
    /// It takes the sliced file as input and returns a new file or an analysis report.
    /// While running, it updates the progress object.
    fn run(
        &mut self,
        slice_config: &SliceConfig,
        slice_result: Arc<Mutex<Option<SliceResult>>>,
        progress: Arc<Mutex<PassProgress>>,
    ) -> JoinHandle<()>;

    /// Returns the run state of pass.
    fn state(&self) -> Arc<RwLock<PassState>>;

    /// Returns the result of the pass.
    fn result(&self) -> Arc<Mutex<Option<PassOutput>>>;
}

/// Scoped guard that automatically transitions the state to `PassState::Running` upon
/// construction, and to `PassState::Completed` on destruction/drop.
pub struct PassRunningGuard {
    state: Arc<RwLock<PassState>>,
}

impl PassRunningGuard {
    pub fn new(state: Arc<RwLock<PassState>>) -> Self {
        *state.write().unwrap() = PassState::Running {
            start_time: std::time::Instant::now(),
        };
        Self { state }
    }
}

impl Drop for PassRunningGuard {
    fn drop(&mut self) {
        let start_time = match *self.state.read().unwrap() {
            PassState::Running { start_time } => start_time,
            _ => {
                tracing::error!("Pass has completed without being in Running state!");
                std::time::Instant::now()
            }
        };
        *self.state.write().unwrap() = PassState::Completed {
            run_time: std::time::Instant::now() - start_time,
        };
    }
}
